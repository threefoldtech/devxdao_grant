<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro36/research_intro.html"><strong aria-hidden="true">1.</strong> GRANT description</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Milestone 1: CasperLabs 1-click blockchain node deployment</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/research_intro.html"><strong aria-hidden="true">2.1.</strong> Decentralised Cloud</a></li><li class="chapter-item expanded "><a href="implementation/implementation.html"><strong aria-hidden="true">2.2.</strong> Implementation</a></li><li class="chapter-item expanded "><a href="implementation/limitations.html"><strong aria-hidden="true">2.3.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="conclusion.html"><strong aria-hidden="true">2.4.</strong> Conclusion</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Milstone 2: CasperLabs blockchain pruning solution design</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro37/research_intro.html"><strong aria-hidden="true">3.1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="status_quo/status_quo_intro.html"><strong aria-hidden="true">3.2.</strong> Status Quo</a></li><li class="chapter-item expanded "><a href="literature/literature.html"><strong aria-hidden="true">3.3.</strong> Literature</a></li><li class="chapter-item expanded "><a href="decentralized_cloud/decentralized_cloud.html"><strong aria-hidden="true">3.4.</strong> Decentralized Cloud</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="solution/tf_quantum_safe_storage.html"><strong aria-hidden="true">3.4.1.</strong> tf_quantum_safe_storage</a></li><li class="chapter-item expanded "><a href="requirements/requirements.html"><strong aria-hidden="true">3.4.2.</strong> requirements</a></li></ol></li><li class="chapter-item expanded "><a href="research/research.html"><strong aria-hidden="true">3.5.</strong> Research</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="research/deployment/casper_deployment.html"><strong aria-hidden="true">3.5.1.</strong> casper_deployment</a></li><li class="chapter-item expanded "><a href="research/qsfs_performance.html"><strong aria-hidden="true">3.5.2.</strong> qsfs_performance</a></li><li class="chapter-item expanded "><a href="research/storage_integration.html"><strong aria-hidden="true">3.5.3.</strong> storage_integration</a></li></ol></li><li class="chapter-item expanded "><a href="solution/solution.html"><strong aria-hidden="true">3.6.</strong> Solution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="solution/tf_quantum_safe_storage.html"><strong aria-hidden="true">3.6.1.</strong> tf_quantum_safe_storage</a></li></ol></li><li class="chapter-item expanded "><a href="implementation/implementation.html"><strong aria-hidden="true">3.7.</strong> Implementation</a></li><li class="chapter-item expanded "><a href="implementation/limitations.html"><strong aria-hidden="true">3.8.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="conclusion.html"><strong aria-hidden="true">3.9.</strong> Conclusion</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Milestone 3: CasperLabs blockchain pruning solution implementation</div></li><li class="chapter-item expanded "><a href="acknowledgement.html"><strong aria-hidden="true">5.</strong> acknowledgement</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="devxdao-grant-proposal-36"><a class="header" href="#devxdao-grant-proposal-36">DEVxDAO GRANT Proposal #36</a></h2>
<p>ThreeFold tech applied for grants with the <a href="https://www.devxdao.com/">DEVxDAO</a> organisation, received approval, and contracts have been signed. There are two grants in total. This repo deals with the research and POC work with regards to grant #36. See also <a href="https://github.com/threefoldtech/grant37">grant #37</a>.</p>
<h2 id="efficient-operations-of-a-layer-1-node-on-a-decentralized-cloud"><a class="header" href="#efficient-operations-of-a-layer-1-node-on-a-decentralized-cloud">Efficient operations of a Layer-1 Node on a decentralized cloud</a></h2>
<p>Layer-1 protocols face a major dilemma that is hard to solve:  either run there nodes in hyperscale datacenters whic provide all the knowledge and capabilities to keep a cloud up and running but lead to a centralised install base of relay on IT Sacy community memmbers that can run the nodes on bare metal outside of the hyperscale cloud providers.  The two options provide a solid foundation to run the layer-1 nodes on but lead to centralissation.  For example AWS as a hypersacaler has made onboarding of ethereums nodes very simple and therefore a. high percentage of the etherum nodes live inside AWS datacenters (https://thenextweb.com/news/ethereum-nodes-cloud-services-amazon-web-services-blockchain-hosted-decentralization).</p>
<p>This is not what layer-1 protocols are about.  They are predominantly about decentralising applications, services, transactions, storage and networking.  To do this on a centralised platform as a way to do it, but we believe that there should eb a healthy balance between relying on hyperscalers, system administrators that can do it decentralised and than a third option which is &quot;easy, one-click deployment method&quot; for anyone that wants to contribute to the project on a decentralised and distributed grid of compute and storage capacity.</p>
<p>ThreeFold have been building such a grid of &quot;data processing and storage&quot; generators for the past decade and is currently in beta operational stage.<br />
These data generators (3nodes) are autonomous and very safe and secure. 3nodes can exists everywhere where there is electricity and network connectivity.  They do not provide access or interfaces for people, both physical and access over the network. Instead of getting “instructions” what to do by a command and control infrastructure they use a distributed ledger (blockchain) to learn what needs to be started or stopped . The 3nodes will start and stop applications (containerized) based on what “workloads” are described in this operational blockchain by smart contracts. No administrator, person, owner can make this 3nodes do anything else than what is written in these smart contracts.</p>
<p>The is the results of years of hard work and as stated before this is now operational (beta) and has a dev, test and mainnet.  Mainnet has about 43000 cores, 7PB of SSD and 32 PB of spinning disks online (global) and is growing fast.  For more information please see here: https://explorerv3.grid.tf/.  The current growth strategy for the grid is to build community clouds.  Community clouds are 3node that are integrated in real-estate developments, in green enery projects (solar and wind) and anything real estate where power and network are available.  The first proofpoint of this happening is a project being bilt in Dubai: https://finance.yahoo.com/news/paradise-hills-property-development-threefold-150000884.html.  The working assumption here is there will be a fast growing amount of community clouds developed and available over the coming months and years and therefore it can be a valuable addition to the Casperlabs node footprint.</p>
<p>This grant proposal wants to make all of this technology available to the Casperlabs community and help it to prospher and excel in a number of different ways.</p>
<ol>
<li>Enhance the footprint of CasperLabs nodes the ability to deploy nodes outside of hyperscaler datacenters and inside communities of people optimising network access and cost</li>
<li>Enhance the carbon footprint of the CasperLabs nodes by using energy efficient 3nodes and built in carbon offsets</li>
<li>Enable people in developing countries to partake in this project and allows them to build local smart contracting solution to prospher their local economy and become less dependent on the rest of the world.</li>
</ol>
<p>This can all be done with the technology as it stands today and it s good proofpoint / first milestone to achieve. The bigger benefit is something that  needs to be developped but has already a substantial number of building block ready to go.  The ultimate goal of this grant proposal is to create and bild a blockchain pruning mechanism that allows the blockchain to grow forever and have cost efficient nodes everywhere securing operations of the layer 1 protocol</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<h3 id="benefit"><a class="header" href="#benefit">Benefit:</a></h3>
<p>DEVxDAO ecosystem will benefit from grant proposal results  because it will create distributed, decentralised data processing and storage capabilities.  <em>outside</em> of market leading hyperscalers.  There simply is no alternative today that offer the same scalability, security, compatibility with industry leading technology stacks (infrastructure as code like terraform etc).  It also combines people to participate in the production of cloud capacity everywhere creating a solid base for local economous to built innovation and solutions on.</p>
<p>It stimulates the community on the following aspects:</p>
<ul>
<li>Equal rights for everyone</li>
<li>Digital inclusion</li>
<li>Access to education &amp; information</li>
<li>Only 1 digital identity / own your data</li>
<li>Infinite experiences</li>
<li>no abuse = ‘stop being a product’ good for the planet</li>
<li>Lower carbon emissions</li>
<li>Enables a global conscious ecosystem</li>
<li>The internet by itself up to 10x less energy usage</li>
</ul>
<p>It's a solid foundation for innovation and present the opportunity to solve one of the largest problems in the current blockchain landscape (data</p>
<h2 id="total-grant-250000"><a class="header" href="#total-grant-250000">Total Grant: 250000</a></h2>
<ul>
<li>Team Member 1 : Kristof de Spiegeleer</li>
<li>Team Member 2 : Jan de Landtsheer</li>
<li>Team Member 3 : Andreas Hartl</li>
<li>Team Member 4 : Chris Hutton</li>
</ul>
<h2 id="milestone-1"><a class="header" href="#milestone-1">Milestone #1</a></h2>
<h3 id="milestone-title-create-the-ability-to-run-layer-1-blockchain-nodes-on-the-grid"><a class="header" href="#milestone-title-create-the-ability-to-run-layer-1-blockchain-nodes-on-the-grid">Milestone title: Create the ability to run layer-1 blockchain nodes on the grid.</a></h3>
<p>The portion that the OP is requesting from the total grant for the milestone: 10000</p>
<h3 id="due-date-now"><a class="header" href="#due-date-now">Due date: now</a></h3>
<h3 id="details-of-what-will-be-delivered"><a class="header" href="#details-of-what-will-be-delivered">Details of what will be delivered:</a></h3>
<p>The 1-click blockchain (Casper Labs and / or others) node deployment solution - powered by ThreeFold's P2P cloud, using Terraform and/or Docker.  The 
ThreeFold grid has been up and running since 2018 and has a large quantity of compute and storage resources.  The TF Grid is owned by independent farmers 
that believe in decentralized capacity generation everywhere.
Over the last year, a number of blockchain projects have been looking for easy deployment options to allow their communities to have an alternative to &quot;run a node on centralised clouds&quot; to do it all yourself. We can offer a super exciting way here on top of our TFGrid.</p>
<h3 id="acceptance-criteria"><a class="header" href="#acceptance-criteria">Acceptance Criteria:</a></h3>
<p>All agreed layer 1 blockchain technologies have a &quot;single click&quot; deployment mechanism.  All the current members of the ETA are considered to be candidates 
for grid deployments.</p>
<h2 id="milestone-2"><a class="header" href="#milestone-2">Milestone #2</a></h2>
<h3 id="milestone-title-rd-for-a-whitepaper-on-blockchain-pruning-possiblities-for-the-casperlabs-layer-1-blockchain"><a class="header" href="#milestone-title-rd-for-a-whitepaper-on-blockchain-pruning-possiblities-for-the-casperlabs-layer-1-blockchain">Milestone title: R&amp;D for a whitepaper on blockchain pruning possiblities for the CasperLabs layer-1 blockchain.</a></h3>
<p>The portion that the OP is requesting from the total grant for the milestone: 50000</p>
<h3 id="due-date-july-2022"><a class="header" href="#due-date-july-2022">Due date: July 2022</a></h3>
<h3 id="details-of-what-will-be-delivered-1"><a class="header" href="#details-of-what-will-be-delivered-1">Details of what will be delivered:</a></h3>
<h3 id="acceptance-criteria-1"><a class="header" href="#acceptance-criteria-1">Acceptance Criteria:</a></h3>
<p>Operational plaform and layer-1 protocols deployed</p>
<h2 id="milestone-3"><a class="header" href="#milestone-3">Milestone #3</a></h2>
<h3 id="milestone-title-blockchain-pruning-mechanism-for-the-casperlabs-layer-1-blockchain"><a class="header" href="#milestone-title-blockchain-pruning-mechanism-for-the-casperlabs-layer-1-blockchain">Milestone title: Blockchain pruning mechanism for the CasperLabs layer-1 blockchain.</a></h3>
<p>The portion that the OP is requesting from the total grant for the milestone: 190000</p>
<h3 id="due-date-december-2022"><a class="header" href="#due-date-december-2022">Due date: December 2022</a></h3>
<h3 id="details-of-what-will-be-delivered-2"><a class="header" href="#details-of-what-will-be-delivered-2">Details of what will be delivered:</a></h3>
<h3 id="acceptance-criteria-2"><a class="header" href="#acceptance-criteria-2">Acceptance Criteria:</a></h3>
<p>Operational plaform and layer-1 protocols deployed</p>
<h2 id="enabled-with-publishingtools"><a class="header" href="#enabled-with-publishingtools">enabled with publishingtools</a></h2>
<p>How to use gitpod see publishingtools documentation https://library.threefold.me/info/publishtools</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decentralised-cloud"><a class="header" href="#decentralised-cloud">Decentralised Cloud</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<p>Recommendation is to do the POC (milestone 2) in Q1/Q2 of 2022.  Threefold is able to free up the engineering resources based on the proceeds of milestones 1 part of the grant and the outlook to receive the proceed for milestone number 2.</p>
<blockquote>
<p>TODO: need to describe we already did 70% of the work, ...</p>
</blockquote>
<p>describe timing, planning, what to do by when, ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations"><a class="header" href="#limitations">limitations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>This research document represents the first milestone in the grant that has been awarded by DEVxDAO. This document will lay out the challenges that need to be overcome to create a lasting generic solution for the blockchain forever growing data storage problem and then identifies solution paths to this challenge. This document will present a number of solution paths to be looked at and then, as a conclusion, a small numbers of solution paths will be selected for implementation in milestone 2 of this grant.  This documenent is not intended to provides the solutions themselves, more time and proper research and development in the POC phase is required.</p>
<p>Extensive research has been done by a group called ThreeFold into creating a decentralized technology with compute and storage capabilities to build a new internet that is not in the hands of a few monopolies. This research is centered around a solid &quot;layer-0&quot; software stack and we intend to put it to work in conjunction with new innovation to find a decentralized autonomous solution to the blockchain pruning problem.</p>
<p>This research document will look at publications and literature to see what history has taught us how to deal with growing datasets and increasing importance of digital data. Areas that will be investigated are the well known area of backups (full and incremental) and archiving. Another area which might get us some insights is de-duplication of data before it is archived or backed up. Also, we will look at other publications describing research or projects about finding a (partial) solution to the pruning challenge.</p>
<p>After reviewing what has been developed, implemented and proposed as solutions, we will present a number of methods by which we believe we can get to an acceptable pruning solution. We will present SWOT analyses on the methods presented and select the few that are most feasible to get to the required result.</p>
<p>The selected methods will then be architected to a level where we can see how this would work in a real life situation and what is required to achieve this. Recommendations for the second milestone will be presented and risks and limitations will be cited.<br />
The conclusion of this document will act as a starting point for milestone 2 work.</p>
<p>!!!include:ms1_goal</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="current-solutions-to-forever-growing-data-in-blockchains"><a class="header" href="#current-solutions-to-forever-growing-data-in-blockchains">Current solutions to forever growing data in blockchains</a></h2>
<p>A non-exhaustive list of ways to deal with the data growth issue is:</p>
<ul>
<li><em>Compress data</em>: keep storing data as is but lower the impact / footprint of it.</li>
<li><em>Lower the number of full nodes in a blockchain</em>: make the number of nodes smaller in order to have less copies of the data distributed which lowers the synchronization requirements (to retain a high transaction speed) and limit the overall hardware needed to operate the full nodes.  This can be done by staking mechanisms and creating a set number of full nodes available in a chain.</li>
<li><em>Create a hierarchy of nodes</em>: split the blockchain functionality in components that together make up the full blockchain.</li>
<li><em>Shard the blockchain</em>: split the chain itself into smaller pieces that communicate through a single coordination chain</li>
</ul>
<p>All of these solutions have their disadvantages and none of the solutions solve the basic problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literature"><a class="header" href="#literature">Literature</a></h1>
<p>This section will provide an overview of some of the literature and publications that have been looked at in order to select a number of methods to find solutions paths for a generic pruning solution.  It will highlight technologies (old and new) when brought together can provide a generic pruning solution.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="existing-decentralization-projects"><a class="header" href="#existing-decentralization-projects">Existing decentralization projects</a></h2>
<p>There are a number of project operational that are creating decentralised utility for data processing and storage. ThreeFold is a multidisciplinary project which touches all of the bases for creating a new IT stack fueling the Internet.
<img src="decentralized_cloud/../img/tf_comparison.png" alt="tf_comparison" /></p>
<p>To the extent that it provides a complete suite for hosting a decentralized protocols' computation, storage, and network requirements, ThreeFold technology is a logical foundation for any forward looking decentralization initiative.</p>
<h2 id="threefold-decentralized-autonomous-compute-and-storage"><a class="header" href="#threefold-decentralized-autonomous-compute-and-storage">ThreeFold Decentralized (autonomous) compute and storage</a></h2>
<p>ThreeFold is a project the seeks true decentralization for traditional IT capacity generation. They are creating a foundational layer for the internet, cloud and layer-1 blockchain protocols.</p>
<p>We might not realise everyday but the internet is in the hands of a handful of large organizations that make the internet work as it works today in a very centralized way. There are two camps:</p>
<ul>
<li>network providers: mostly the Tier 1 players that have been working together since the inception of the internet to guide and direct traffic and have been providing interconnect services for lower tiers, national and regional players to the rest of the world.</li>
<li>datacenter (or a more modern version of them, cloud) providers.  Datacenters are the end point for all the networks  Datacenters are (literally) massive warehouses that house servers on which (most, if not all today) of the internet content and services are processed and stored.  This includes today public services, private services, freemium services bot also mostly all of the blockchain projects rely on massive cloud providers providing them with data processing and storage services.</li>
</ul>
<p><img src="decentralized_cloud/img/threefold_supernode_.jpg" alt="threefold_architecture" /></p>
<p>So this internet is governed my a small number of network providers that <em>decide</em> how internet traffic flows are and who gets to pay for transit services and who not (internet transit between two parties where no money exchanges hands is called peering) and a small number of datacenter that control all the content on the internet, get freemium information about consumer behavior and know everything about us.</p>
<p>ThreeFold is pushing a technology stack into the world where the people are back in the capacity (data processing and storage) production role and also provide this produced capacity to consumers of capacity that have access to efficient, sustainable, decentralized and affordable capacity without being caught in a walled garden of a large centralized provider.</p>
<p>Find more information here:</p>
<ul>
<li>website: http://www.threefold.io</li>
<li>library: http://library.threefold.me</li>
</ul>
<h4 id="what-does-threefold-bring"><a class="header" href="#what-does-threefold-bring">What does ThreeFold bring</a></h4>
<p>ThreeFold brings a technology stack that undoes a lot of the (unnecessary) complexity that currently exits in the world of Internet and more generic the world of Information Technology.  This technology stack includes:</p>
<ul>
<li>an autonomous, secure, lightweight and efficient operating system that enables anyone to create data processing and storage capabilities everywhere where electricity meets connectivity.</li>
<li>the use of (any) blockchain to do value transactions and smart contracts for operational IT workloads descriptions.  Today they use the Stellar Network and Polkadot substrate as the main two blockchains. Their strategy is to become a multichain platform and provide decentralized smart contracting capabilities for IT architectures that can run any IT workload currently supported on market leading clouds but then 100% decentralized. The most well known cloud interfaces to orchestrate a cloud infrastructure are supported (Kubernetes, Docker, terraform, typescript etc.)</li>
</ul>
<p>In order reach their goal ThreeFold has developed a large number of building blocks that can be molded into an architecture that can achieve blockchain pruning functions without much (if at all) impact to the blockchain operations.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>needs to be put in bigger context, more include from TF</p>
</blockquote>
<h4 id="threefolds-qsfs-as-a-basic-building-block-for-blockchain-pruning"><a class="header" href="#threefolds-qsfs-as-a-basic-building-block-for-blockchain-pruning">ThreeFolds QSFS as a basic building block for blockchain pruning?</a></h4>
<p>QSFS stands for Quantum-Safe File System. It is a redundant filesystem, which can store petabytes of information.</p>
<p>Unique features are : </p>
<ul>
<li>Unlimited scalable (many petabytes) filesystem</li>
<li>Data is spread over many devices owned by different, independent hardware owners called farmers. Together, these farmers provide the capacity to a hardware grid, call the ThreeFold Grid. </li>
<li>Dispersion over multiple sites ensures 100% privacy of the data, as no farmer knows what the data is about (zero knowledge storage system). Even a quantum computer cannot decrypt the data on a node, as one node contains insufficient information to unambiguously recreate the authentic data.</li>
<li>Data can’t be lost: there is a protection for datarot, data will auto-repair.</li>
<li>Data is append-only and immutable by design of the protocol, so it’s fit for storing ledger history. Even with sites going down, data is not lost with ‘operational’ backup nodes in place.</li>
<li>Up to 10x more efficient than storing on classic storage cloud systems. Overhead of about 20% is sufficient to have a secure archive.</li>
<li>Can be mounted as filesystem on any OS or any deployment system (OSX, Linux, Windows, Docker, Kubernetes, TFGrid, ...).</li>
<li>It is compatible with +/- all data workloads (exception: high performance data driven workloads like a database).</li>
<li>Self-healing: when node or disk lost, storage system can get back to original redundancy level.</li>
<li>Helps with compliance to privacy regulations like GDPR (as the hosting facility has no view on what is stored, information is encrypted and incomplete).</li>
<li>Hybrid : can be installed onsite, public, private, ...</li>
<li>Read-write caching on encoding node (the front end).</li>
</ul>
<h4 id="threefold-qsfs-sub-components"><a class="header" href="#threefold-qsfs-sub-components">ThreeFold QSFS sub-components</a></h4>
<p>QSFS being a prime candidate to consider for blockchain pruning purposes has a number of sub-components that can be put to use for achieving the pruning solution.  Here's a brief description of some of these:</p>
<h5 id="0-db-storage-engine"><a class="header" href="#0-db-storage-engine">0-db storage engine</a></h5>
<p>This is an always-append database, which stores objects in an immutable format, which allows to have history out-of-the-box, good performance on disk, low overhead, easy data structure, easy backup (linear copy and immutable files).
We use two types of 0-db: </p>
<ul>
<li>One for the storage backend </li>
<li>One for 0-db-fs, which is where data needs to be, to be available via the fuse filesystem. This 0-db can offload its data to an external process (user-defined) and can also request missing data to be retrieved, if some data are missing.</li>
</ul>
<p>This enables the database to spread and not always use local storage space if data is not read.</p>
<p>One external process to handle these cases is 0-stor-v2.</p>
<h5 id="0-db-fs-fuse-layer-which-uses-the-storage-engine-in-an-optimized-way"><a class="header" href="#0-db-fs-fuse-layer-which-uses-the-storage-engine-in-an-optimized-way">0-db-fs FUSE layer which uses the storage engine in an optimized way</a></h5>
<p>This is a simple filesystem driver which uses 0-db as the primary storage engine.
Directories and metadata are stored in a dedicated namespace, file payloads are saved in another dedicated namespace.
The filesystem uses an internal cache system made, not for performance, but to optimize how data is stored in the 0-db, to avoid overhead as much as possible.</p>
<h5 id="0-stor-v2-engine-to-savebackup-data-to-safe-location"><a class="header" href="#0-stor-v2-engine-to-savebackup-data-to-safe-location">0-stor-v2 engine to save/backup data to safe location</a></h5>
<p>This tool can be used as external process for 0-db, or can be used for any purpose. It just takes one file as input, it encrypts this file in AES based on a key user-defined, encodes the file and spreads the data to multiple 0-db’s. Based on the policy (configurable), some amount of 0-db’s can be unreachable, data can still retrieved and missing database can even be rebuilt to keep full consistency available.</p>
<p>Metadata needed to get data back from 0-db in the right order, are stored in others 0-db.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements"><a class="header" href="#requirements">Requirements</a></h1>
<blockquote>
<p>TODO: needs to be broken appart in multiple files, use some tables, ...</p>
</blockquote>
<blockquote>
<p>TODO: think more what do we want to achieve adn putrequirements as such</p>
</blockquote>
<p>A blockchain is in essence a ledger of immutable records that are always append and therefore linked and a chain, The total chain forms the &quot;end state&quot;. In order to proof validity of this end state, the complete history needs to be kept from the genesis time of the blockchain to now. </p>
<p>Blockchains enable organizations to run decentralized, they allow value transaction to be done without a third party in the middle and any other use case of blockchain technology always revolves around decentralization.  The permissionless blockchain provide the most pure form of decentralization where node owners and operators decide for themselves whether the reward for operating a node is sufficient for them to get involved (or not).  Permissioned blockchains have a slightly less decentralized character but certainly have a distributed character where the reward is not just governed by an algorithm because here there might be a legal entity involved to orchestrate the rewards system.  This  legal entity might be a DAO (Distributed Autonomous Organization).</p>
<p>The number and types of implementations of blockchains (supporting the growth in adoptions for traditional use cases and  DAO's) is going to grow exponentially, there is a need for level-1 blockchain protocols to be able to deal with the increased volume of transactions and history, making pruning a necessity.</p>
<p>Increase in data volume and transactions volume will create issues at some point in time, a ledger holding the complete chain data will become too big for a key aspects of a blockchain:</p>
<ul>
<li>fast transaction times require minimum synchronization time.</li>
<li>security and proof of validity requires the complete chain to be stored many times over to overcome a 51% attack</li>
<li>decentralized operations is key but operating a full nodes becomes more expensive by excessive chain data growth which in the long run will rule out people that do not have the means to afford such hardware.</li>
</ul>
<p>All of the above threatens the decentralization of any layer-1 blockchain project in general.</p>
<p>From the literature researched we formed ideas how we can come to a &quot;non intrusive&quot; pruning system for regular blockchain protocols without necessarily make major changes to the existing blockchain and consensus algorithms. To form such a solution there are a number of technology components that will make creating such a solution possible or easier to create.  To architect methods to solve this problem we have opted to use the ThreeFold data processing and storage stack which presents a unique decentralized utility / cloud platform with some unique storage capabilities that will make developing this solution possible.</p>
<h2 id="solution-architecture"><a class="header" href="#solution-architecture">Solution architecture</a></h2>
<p>To honor decentralization aspect the of any chain data the pruning solution cannot be governed or owned by one (or a few) legal entities, it has to follow the same principle of being permissionless or somehow permissioned with a DAO governing the permissioned aspects. </p>
<p>To make this work we have to create a set of requirements to what the solution needs to be designed to.</p>
<h3 id="high-level-requirements"><a class="header" href="#high-level-requirements">High level requirements</a></h3>
<p>In order to start looking at solutions let's first draft some requirement that we believe are instrumental to the solution.  The requirements are:</p>
<ol>
<li>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software.</li>
<li>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes <em>or</em> it should use a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO.</li>
<li>2the pruning solution should store the chain data such that it provides a proof of recovery method </li>
<li>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</li>
<li>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</li>
</ol>
<!-- ### Protocol

The protocol solving the storage and pruning challenge consists of the following : 
- The current state is kept locally and recalculated when new transactions come in, before spreading it out;
- Historical transactions are directly stored in QSFS, available for consultation and synchronisation purposes (in case new validators join). 
- The history is organised as one file system, which constitutes the data using chunks from different redundant shards, hosted on storage infrastructure of multiple independent hardware providers. Each of the shards contains insufficient information to recollect the original data, but using all shards combined allows to recollect the pieces with minimal overhead. 

#### Challenges and solutions to it

- Make sure that the data is sufficiently decentralized, i.e. spread over shards that are hosted on infrastructure of different providers. 
- Make sure that these 'shard hosters' keep the storage available, or that a sufficient amount of shards are recreated at a moment that shards become unavailable. The storage nodes need to remain alive. The consensus mechanism determines the need for incentivisation mechanisms. 
  - In a permissioned blockchain, using a Proof of Authority consensus driven blockchain, there is no real issue: here the participants have interest to have all history available, and no incentive is needed for them to make this happen. The QSS, in this case, is a way for participants to substantially reduce the need for space, remaining equally responsible for the history of transactions. 
  - In a permissionless blockchain, we need to find a mechanism to incentivize participants to keep also transaction history available, and even 'punish' node owners tricking the system, ex. retrieving the info by proxy-ing the service. A few ideas to cope with this issue : 
    - apply a higher-level protocol to interrogate the provider 
    - build into the protocol itself, and put the metadata on-chain

A node could be requested to provide a specific shard and hash it with a timestamp or specific nonce included, maybe running their own personalised 0-stor protocol instance.
The proof can be a merkle tree + root hash + a requested block, with the hash made based taking up a nonce/timestamp.-->
<h3 id="necessary-conditions"><a class="header" href="#necessary-conditions">Necessary conditions.</a></h3>
<p>Taking the high level requirements into consideration we take the following necessary conditions on board to design the solution:</p>
<p><strong>Necessary Condition 1 (NC1)</strong>. <em>Secure, autonomous, decentralized and distributed data processing and storage utility</em></p>
<p>To create autonomous, decentralized and distributed data processing and storage utility we need an operating system that provides maximum security by not allowing people to give it instructions or configure it.  To reach a distributed and decentralized grid of processing and storage capacity we cannot rely on people to install and operate standard operating systems.  A standard operating system would allow individual owners of these nodes to be able to see (and potentially manipulate) the incoming data parts to be stored.</p>
<p>ThreeFold has developed such an operating system that gets its instructions from a decentralized ledger where a smart contract governs the execution of such operational instructions.  Such an operating system would allow the compute and storage nodes involved in the pruning solution to be safe, private, sovereign and autonomous  in it's operations.</p>
<p><strong>Necessary condition 2 (NC2)</strong>. <em>Immutable and always-append storage device</em></p>
<p>Use a low level storage device that uses physical storage similar to how a blockchain create chain data: always append and immutable.  When data is committed to this storage device it cannot be deleted.  The data is committed and stored on this storage device for as long as this device is part of the storage system for pruned data.</p>
<p><strong>Necessary condition 3 (NC3)</strong>. <em>Encrypted secure networking</em></p>
<!--  (maybe to be deleted, as there's not really data to secure when pruning) -->
<p>Use secure and encrypted networking between the blockchain nodes and the <em>remote</em> storage utility.  Chain data needs to be transported off node and we need to have certainty that data cannot be changed or messed with in the transport part of the pruning process. Therefore encrypted networking using an overlay network technology is an important component for taking chain data off blockchain nodes.</p>
<p><strong>Necessary condition 4 (NC4)</strong>. <em>A filesystem that presents remote storage to blockchain node</em></p>
<p>For minimal to no impact to general blockchain nodes, the off-node storage utility should be presenting itself on the blockchain node as a normal filesystem.  All activities of storing data away from the blockchain node and creating the necessary proof points along the way should require minimal to no impact on the blockchain software.  Proof point should include:</p>
<ul>
<li>authenticity of being pruned from a particular node</li>
<li>comparing off chain data from different nodes to contain the same data</li>
<li>de-duplicating data</li>
<li>other activities to condense the data footprint and make the whole blockchain more efficient and scalable</li>
</ul>
<p>Some blockchain protocols have built in capabilities that allow partial backup of chain data and provide the required proof of the authenticity of the partial backup which makes the remote storage filesystem an ideal way to take data off-node.</p>
<p><strong>Necessary condition 5 (NC5)</strong> . <em>Secure access to remote stored and de-duplicated data</em></p>
<p>Provide secure access to the stored history of the chains and make all nodes (ideally) use de-duplicated copies of the historic data.</p>
<p><strong>Necessary condition 6 (NC6)</strong>. <em>Proof of recoverability</em></p>
<p>When data is stored off node in a de-duplicated format there should be a regular check if the pruned data is recoverable.  This necessary condition will also create the opportunity for new nodes to join at and start validating and securing from the current chain state while in the background cycling back the the genesis block on the pruned chain data and create proof of recoverability for the while chain. </p>
<h2 id="solution-components"><a class="header" href="#solution-components">Solution components</a></h2>
<p>To fullfil the necessary conditions mentioned earlier there are a number of components in the ThreeFold technology stack that meet these condition and will be considered to be part of the pruning solution.  Here is a brief description of how components meet the conditions.</p>
<h3 id="nc1-secure-and-autonomous-operating-system"><a class="header" href="#nc1-secure-and-autonomous-operating-system">NC1: Secure and autonomous Operating System</a></h3>
<p>The principles to build a secure and autonomous operating system to build a decentralized and distributed grid of capacity are as follows:</p>
<ul>
<li><em>Autonomy</em>: to create compute, storage and networking capacity everywhere you can not rely on a remote (or a local) maintainer of the operating system. Also owners should not have to be operating system administrators.  By making the OS autonomous and not allowing owners or systems administrators to log in to the OS you make it a very secure operating system.</li>
<li><em>Simplicity</em>: An operating system should be simple, able to exist anywhere, for anyone, good for the planet.  Simplicity also enhances the overall security of a system </li>
<li><em>Stateless</em>: In a grid (Peer To Peer) set up, the sum of the components is providing a stable basis for single elements to fail and not bring the whole system down. Therefore, it is necessary for single elements to be stateless, and the state needs to be stored within the grid.</li>
</ul>
<img src="requirements/./img/threefold__zero_os_overview.jpg" alt="threefold_zero_os_overview" width="800"/>
<p>Building an autonomous, simple and stateless OS is not an easy feat.  Not having access means that is has to be 100% right at time of deployment.  Zero-OS has been developed and improved over the last 5 years and is now ready to be the capacity generator for secure IT workloads where compute, storage and networking components interact.</p>
<h3 id="nc2-immutable-and-always-append-storage-protocol"><a class="header" href="#nc2-immutable-and-always-append-storage-protocol">NC2: Immutable and always-append storage protocol</a></h3>
<p>In such an autonomous operating system storing data can be done in a very secure manner.  As owners, administrators and users do not have direct access to the operating system a very secure environment is created to run applications and store data.  Also since this operating system is made to form a grid creating ubiquitous compute, storage and network utility local storage devices can be used to make a &quot;dispersed&quot; storage system.</p>
<p>At the foundation of such a dispersed storage system sits a zero-DB.
Zero-db is a fast and efficient key-value store (redis-protocol compatible), which makes data persistent inside an always append data file, with namespaces support.  This zero-DB is able to receive and send information over a secure network that spans between all the zero-OS's and as such many zero-DB's can together create a large storage lake.</p>
<p>The Zero-DB stores data like a key-value store, and can operate (when configured to do so) to store data sequentially which makes it an &quot;always append&quot; storage device.  For caching purposes it can also be configured to not do this.</p>
<img src="requirements/./img/threefold__zdb_arch.jpg" alt="threefold_zdb_arch" width="800"/>
<h3 id="nc3-encrypted-secure-networking-the-planetary-network"><a class="header" href="#nc3-encrypted-secure-networking-the-planetary-network">NC3: Encrypted secure networking: the Planetary Network</a></h3>
<p>The planetary network is an overlay network which lives on top of the existing internet (or any other network created). In this network, everyone can direct connect to everyone and routing does not rely on ISP and Tier 1 providers routing tables. The technology uses a Distributed Hash Table that allows all participating nodes to find the best network path to where it needs to send data. End-to-end encryption between application on the zero-OS's.</p>
<p>Each user and network point is strongly authenticated and uniquely identified, independent of the network carrier used. There is no need for a centralized firewall or VPN solutions, as there is a circle based networking security in place.</p>
<p>Benefits :</p>
<ul>
<li>shortest possible paths between peers, independent of the network providers routing decisions</li>
<li>end-to-end encrypted data transport create full security</li>
<li>peer2peer links like meshed wireless</li>
<li>broken internet links do not affect the operating of traffic by re-routing traffic when needed</li>
</ul>
<img src="requirements/./img/threefold__planet_net_.jpg" alt="planetary_network" width="800"/>
<h3 id="nc4-filesystem-that-presents-remote-storage-to-blockchain-node"><a class="header" href="#nc4-filesystem-that-presents-remote-storage-to-blockchain-node">NC4: Filesystem that presents remote storage to blockchain node</a></h3>
<p>Quantum Safe Storage System uses a dispersed storage algorithm to distribute the data in a smart way and store data in different locations. The original object is fragmented, compressed and encrypted, and than a &quot;description&quot; is created of that compressed and encrypted fragment which is stored. The original compressed and encrypted data is deleted.  Only that description of that data part  of the information is stored, making it impossible to understand what data(part) is stored on a single device as you need all the descriptions together to be able to &quot;un-describe&quot; the compressed and encrypted original data</p>
<p>The data is described in a way such that a person aiming to hack into the low-level data (which is almost impossible in itself), will only find non-relevant information on this storage infrastructure and the other data shards can’t be re-created, making it quantum-proof.</p>
<p>Quantum Safe Storage System offers the following storage benefits:</p>
<ul>
<li>Store Petabytes of data at hyper-competitive pricing.</li>
<li>Quantum-safe security (not even a quantum computer can hack).</li>
<li>A filesystem interface see Quantum Safe Filesystem</li>
<li>Unlimited scalability provided by the ThreeFold P2P infrastructure.</li>
<li>Self-healing capability of the storage layer ensures your data remains available at all times.</li>
</ul>
<img src="requirements/./img/threefold__zos_zstor.jpg" alt="zos_zero_store" width="800"/>
<h3 id="nc5-secure-access-to-de-duplicated-data"><a class="header" href="#nc5-secure-access-to-de-duplicated-data">NC5: Secure access to de-duplicated data</a></h3>
<p>...</p>
<p>ThreeFold Tech has developed the technology to store immutable records in a more space efficient way, relying on a fully decentralized grid of storage capacity. No participant has the full storage volume on his hard drive, however the combination of all participants allows recomposing of the full ledger with all records. This method brings many benefits: </p>
<ul>
<li>The storage happens in a very, quantum-resilient way, as attacking one chunk gives insufficient information to recreate the authentic data;</li>
<li>Storage grows slower over time compared to a classic blockchain setup, as storage overhead can be limited to about 20% instead of the ‘traditional’ 10000% (in the case of 100 participants running a blockchain node) overhead;</li>
<li>It allows for an easy way to implement pruning: only the current state is really required to be stored locally, and when transactions come in, a recalculation is made, and the storing of the historical transactions is directly done using QSFS</li>
</ul>
<h3 id="nc6-proof-of-retrievability-por"><a class="header" href="#nc6-proof-of-retrievability-por">NC6: Proof of Retrievability (POR)</a></h3>
<p>We need to have a way for archived chain to have proof of retrievability (POR). A POR is a protocol in which a server/archive proves to a client that a target file F is intact, in the sense that the client can retrieve all of F from the server with high probability.</p>
<p>For a good working pruning solution POR is a necessary conditions</p>
<h2 id="proposed-solution-methods-to-architect-a-pruning-solution"><a class="header" href="#proposed-solution-methods-to-architect-a-pruning-solution">Proposed solution methods to architect a pruning solution</a></h2>
<h3 id="introduction"><a class="header" href="#introduction">Introduction</a></h3>
<p>For many blockchain nodes every (full / validator) node that partakes in the blockchain operation run the layer-1 blockchain software which is part of the blockchain operations.  At this point in time we leave the complexities out that come with the the blockchain being permissionless or permissioned.  This has major impact on how nodes build trust between themselves and the resulting consensus mechanism that operates the blockchain protocol.  For this part of the research we are going to focus on how these blockchain nodes store that data after consensus and trust has been build between all participating nodes.</p>
<h3 id="method-1-use-traditional-full-and-incremental-backup-principles-to-backup-a-database-offchain"><a class="header" href="#method-1-use-traditional-full-and-incremental-backup-principles-to-backup-a-database-offchain">Method 1: Use traditional full and incremental backup principles to backup a database offchain</a></h3>
<h4 id="description"><a class="header" href="#description">Description</a></h4>
<p>Any blockchain node uses local available disk drives to write its full chain data and chain state to.  For some (layer-1) protocols a database is used (like <a href="https://github.com/LMDB/bitmonero">Monero</a>) and for others other data formats have been chosen. These formats might be databases, key values stores or other means of putting data in a structured format before committing it to disk.</p>
<p>Popular cryptocurrencies use a mix of LevelDB and BerkeleyDB. High-performance blockchain databases such as BigchainDB and ProvenDB are using MongoDB.  So each blockchain node runs a local database of sort to store its local chain data and indexes it in a certain way to make it searchable and fast responding to queries.</p>
<img src="requirements/../img/blockchain_local_operation.svg" alt="blockchain_pruning_option_1" width="800"/>
<p>In such a setup one can look at database specific export or backup features to partial exports and backups to store a part af the chain data off-node.</p>
<img src="requirements/../img/blockchain_local_operation_pruning.svg" alt="blockchain_pruning_option_1" width="800"/>
<p>In this method the blockchain node database is used to create a periodic export of the database and all of it's new stored blocks and it is store on a local fuse based file system than has a local storage devices for physical storage.  The fuse filesystem has hooks built in to engage an erasure coding engine that takes the new data, create data fragments from it, compresses and encrypts tha fragments and then creates a mathematical description of these fragments (plus creates mode mathematical descriptions based on the same compressed and encrypted fragments to create redundancy).  For a more detailed description how this works please see <a href="https://library.threefold.me/info/threefold#/qss/threefold__qss_algorithm">here</a>.</p>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Requirement</th><th style="text-align: center">Achieved?</th><th style="text-align: center">Remarks</th></tr></thead><tbody>
<tr><td style="text-align: left">pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td style="text-align: center">yes</td><td style="text-align: center">1.</td></tr>
<tr><td style="text-align: left">the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td style="text-align: center">yes</td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: left">the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td style="text-align: center">No</td><td style="text-align: center">2.</td></tr>
<tr><td style="text-align: left">the pruning solution should store the chain data such that it provides a proof of recovery method</td><td style="text-align: center">TBD</td><td style="text-align: center">3.</td></tr>
<tr><td style="text-align: left">the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: left">the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<p><em>Remarks</em></p>
<ol>
<li>this methods uses all of the participating node to run software and store data. The fragment dispatcher and dedupe process creates consensus on which fragment is stored on what node and creates meta data to be able to retrieve the de-duplicated DB export container chain data.</li>
<li>the external storage facility to the node are all the other blockchain nodes <code>N-1</code>.  Since the blockchain protocol builds trust and consensus the trust is implicit here.</li>
<li>the proof of recovery method is working for a file based storage system build with this technology where there is a single data injection point.  In this use case there are <code>N</code> data injection points which is theoretically inject the same data. The proof algorithm needs to be build but research shows that this can be done.</li>
</ol>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th style="text-align: center">Achieved?</th><th style="text-align: center">Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td style="text-align: center">Yes</td><td style="text-align: center">1.</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td style="text-align: center">Yes</td><td style="text-align: center">2.</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td style="text-align: center">Yes</td><td style="text-align: center">3.</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td style="text-align: center">Yes</td><td style="text-align: center">4.</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td style="text-align: center">Yes</td><td style="text-align: center">5.</td></tr>
</tbody></table>
</div>
<p><em>Remarks</em></p>
<ol>
<li>The ThreeFold stack is version 3 and has a proven track record of providing decentralised and distributed data processing and storage utility.</li>
<li>This is what zero-DB has been designed to do. Please find more information <a href="https://github.com/threefoldtech/0-db">here</a></li>
<li>The ThreeFold planetary network does exactly this. PLease find more information <a href="https://github.com/threefoldtech/TF-NetworkConnector_">here</a></li>
<li>Please find mode information <a href="https://github.com/threefoldtech/quantum-storage">here</a></li>
<li>the proof of recovery method is working for a file based storage system build with this technology where there is a single data injection point.  In this use case there are <code>N</code> data injection points which is theoretically inject the same data. The proof algorithm needs to be build but research shows that this can be done.</li>
</ol>
<h3 id="method-2-install-and-use-additional-software-on-the-node-to-prune-chain-data"><a class="header" href="#method-2-install-and-use-additional-software-on-the-node-to-prune-chain-data">Method 2: Install and use additional software on the node to prune chain data</a></h3>
<p>Method 2 is about integrating the backup tooling into the node software. Fuse file system will be created on a node, and data will be sent to ZSTOR. Then, a proof process is executed to build consensus on the same data that is archived in zstor as the one that was used in the block validation consensus. A block is split up in fragments, parity blocks are added for both the data and for the proofs. Once fragments are created, they are distributed over different nodes: each of p+q nodes stores one of the created fragments, into the zdb present in the node. </p>
<img src="requirements/../img/pruning_block_write_option_1.svg" alt="blockchain pruning option 1" width="800"/>
<p>&lt;<Scott to complete>&gt;</p>
<p><strong>Necessary conditions</strong> </p>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td>No</td><td>No</td></tr>
<tr><td>the pruning solution should store the chain data such that it provides a proof of recovery method</td><td>TBD</td><td>No</td></tr>
<tr><td>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td>Yes</td><td>No</td></tr>
<tr><td>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td>Yes</td><td>No</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td>Yes</td><td>No</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td>Yes</td><td>No</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td>Yes</td><td>No</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td>Yes</td><td>No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="method-3-integrate-pruning-software-module-into-permissionless-blockchain"><a class="header" href="#method-3-integrate-pruning-software-module-into-permissionless-blockchain">Method 3: Integrate pruning software module into permissionless blockchain</a></h3>
<p>Method 2 could work well in a permissioned setup. 
Method 3 is an add-on to method 2 to make it also work in a permissionless consensus model. </p>
<p>The problem with permissionless setups is the fact that there is no hard commitment from the validators that they will continue operating, and that a validator expects some incentive in return for the validator services provided. Especially when dealing with historic information, current consensus models only provide in rewards for closing the current blocks, with the 'obligation' to also keep history up. This leads to the high redundancy in storage. Pruning in these setups is only solved creating a hierarchies in the node structure, which is contradictory to the decentralized nature of permissionless blockchains. </p>
<p>We propose a four-step approach for a non-hierarchical pruning protocol that works in a permissionless setup. It involves elections for the storage of historic batches, each time a new batch of blocks is being built. </p>
<h4 id="step-1--consensus"><a class="header" href="#step-1--consensus">Step 1 : Consensus</a></h4>
<p>The first step in the consensus protocol does not change: n nodes agree on validity of blocks. Once consensus is achieved (using whatever consensus protocol like PoS, PoW, ...) records are stored and de-duplicated over all n nodes. 
With one difference, however, which is that the transactions are stored in a Z-Stor dedupe format, over p storage nodes + q redundant ones (typically 20% of overhead) in a Zero-DB format. </p>
<h4 id="step-2--fill-block-batch"><a class="header" href="#step-2--fill-block-batch">Step 2 : Fill block batch</a></h4>
<p>We propose to group a number of blocks, either for an agreed number of blocks. Idea is to come to a sufficient volume to put aside (ex. 30 MB), and keep the transactional history on-chain as long as the agreed block number hasn't been reached. During this period, history is collected in n*(p+q) equal chunks of data.</p>
<h4 id="step-3--batch-closing"><a class="header" href="#step-3--batch-closing">Step 3 : Batch closing</a></h4>
<p>Once the agreed block number has been fully completed (= consensus achieved), the chunks are closed and are ready to be put off-chain. The zstor format ensures that data is immutable, a fingerprint is created and linking information to where the chunks can be found. This information is registered on-chain. </p>
<h4 id="step-4--off-chain-storage-follow-up"><a class="header" href="#step-4--off-chain-storage-follow-up">Step 4 : Off-chain storage follow-up</a></h4>
<p>A few challenges arise with this setup :</p>
<ul>
<li>Data rot can happen, a node can disconnect or other events can happen making that a node starts behaving as a bad actor. </li>
<li>Every time a batch is closed, the metadata describing the location of the historic batches also go off-chain. </li>
</ul>
<p>Both elements require an active follow-up of where historic batches of transactions are to be found is needed. 
This is why the following is proposed:</p>
<ul>
<li>Within each new storage batch process, a process is launched to register the location of historic batches on the new active part of the chain. </li>
<li>Over time, a number of batches are created. Let's call the number of completed batches <code>y</code>. </li>
<li>An election needs to happen of <code>y * (p + q)</code> chunks. During this election, nodes propose the storing of a chunk, with a number of rules: 
<ul>
<li>The number of eligible chunks per batch per node is less than q (and preferably 1), in order to guarantee that the information is decentralized enough to ensure continuity of service in case a node gets disconnected. </li>
<li>A batch can't be closed as long as the election process for each of the <code>y * (p + q)</code> hasn't been completed. </li>
<li>An election process is triggered by 'candidates', launching a 'proof of storage' transaction, indicating the location of the chunk and a fingerprint of the data including recent info (nonce, timestamp, ... ) and proof of authenticity. The election process for a history batch is completed once <code>p + q</code> transactions are selected. </li>
</ul>
</li>
<li>For older chunks, re-election in every new active batch is possible. However, a chunk storage holder should present his 'proof of storage' in every new batch. </li>
<li>In a permissioned model, the election of new chunk holders is part of the authority rights, and no incentive is to be foreseen. For permissionless models, an incentivization mechanism needs to be worked out for every new election. </li>
</ul>
<h4 id="how-to-split-up-the-data-chunks-when-a-batch-has-just-been-completed-"><a class="header" href="#how-to-split-up-the-data-chunks-when-a-batch-has-just-been-completed-">How to split up the data chunks when a batch has just been completed ?</a></h4>
<p>At batch completion, there are logically n*(p+q) chunks available. However, this completed batch can't be pruned until the completion of the next batch, during which election happens of p+q 'historic chunk batch holders'. 
Number of chunks for every election needed is p+q, with p and q natural numbers and p&gt;1, q&gt;0. q=0 is not viable, as data rot might occur, so the idea is that there is always an objective to keep p+q chunks available, and when a chunks gets unreachable, a new chunk is being created.</p>
<p>The intention is to have (p+q) chunks available at any moment in time, for each batch, hence the re-election of every chunk for every new batch. The keeping of 1 or more of these chunks can be incorporated into the validator node code, but will require way less storage volume than the current full nodes. Moreover the storage can be kept off-chain, as an 'active' transaction archive. </p>
<h4 id="how-to-recollect-the-pieces-if-a-historical-transaction-is-to-be-recovered-"><a class="header" href="#how-to-recollect-the-pieces-if-a-historical-transaction-is-to-be-recovered-">How to recollect the pieces if a historical transaction is to be recovered ?</a></h4>
<ul>
<li>In every of the y completed storage batches, all info is available as a transaction to recover y * (p + q) chunks, and with this info the full transaction history can be recovered, using y * p chunks and y * q spare ones. </li>
</ul>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td>No</td><td>No</td></tr>
<tr><td>the pruning solution should store the chain data such that it provides a proof of recovery method</td><td>TBD</td><td>No</td></tr>
<tr><td>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td>Yes</td><td>No</td></tr>
<tr><td>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td>Yes</td><td>No</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td>Yes</td><td>No</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td>Yes</td><td>No</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td>Yes</td><td>No</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td>Yes</td><td>No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="method-4-use-an-external-decentralized-storage-facility-and-uses-chain-consensus"><a class="header" href="#method-4-use-an-external-decentralized-storage-facility-and-uses-chain-consensus">Method 4: Use an external (decentralized storage facility and uses chain consensus)</a></h3>
<p>The most elegant solution would be to have the blockchain node
<img src="requirements/../img/pruning_block_write_option_2.svg" alt="blockchain pruning option 2" width="800"/></p>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td>No</td><td>No</td></tr>
<tr><td>the pruning solution should store the chain data such that it provides a proof of recovery method</td><td>TBD</td><td>No</td></tr>
<tr><td>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td>Yes</td><td>No</td></tr>
<tr><td>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td>Yes</td><td>No</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td>Yes</td><td>No</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td>Yes</td><td>No</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td>Yes</td><td>No</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td>Yes</td><td>No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>Overview of the tests and research we have done to find proof that our suggested solution can work.</p>
<blockquote>
<p>TODO: lots more content in each of the sections.</p>
</blockquote>
<ul>
<li><a href="research/@casper_deployment">casper_deployment</a></li>
<li><a href="research/@qsfs_performance">qsfs_performance</a></li>
<li><a href="research/@storage_integration">storage_integration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO: describe or include info about our deployment solution</p>
</blockquote>
<blockquote>
<p>TODO: create terraform deployment</p>
</blockquote>
<blockquote>
<p>TODO: create kubernetes deployment (or caprover) with monitoring</p>
</blockquote>
<blockquote>
<p>TODO: write down remarks about performance of deployment, requirements of system</p>
</blockquote>
<blockquote>
<p>TODO: do some basic perf tests on the blockchain itself</p>
</blockquote>
<blockquote>
<blockquote>
<p>TODO: maxim or Egypt can help</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qsfs_performance"><a class="header" href="#qsfs_performance">qsfs_performance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_integration"><a class="header" href="#storage_integration">storage_integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="results"><a class="header" href="#results">Results</a></h1>
<p>TBC</p>
<p>This section needs to speak about planning to take 2/3 methods presented forward in the POC phase and implement the pruning solution on.</p>
<p>As this milestone 1 document is a research document it should come to the conclusion that we have identified the technology components we believe that are needed for the solution but the integration and design of how it actually works is part of milestone 2</p>
<blockquote>
<p>TODO: need to describe in this section what our solution is</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>needs to be put in bigger context, more include from TF</p>
</blockquote>
<h4 id="threefolds-qsfs-as-a-basic-building-block-for-blockchain-pruning-1"><a class="header" href="#threefolds-qsfs-as-a-basic-building-block-for-blockchain-pruning-1">ThreeFolds QSFS as a basic building block for blockchain pruning?</a></h4>
<p>QSFS stands for Quantum-Safe File System. It is a redundant filesystem, which can store petabytes of information.</p>
<p>Unique features are : </p>
<ul>
<li>Unlimited scalable (many petabytes) filesystem</li>
<li>Data is spread over many devices owned by different, independent hardware owners called farmers. Together, these farmers provide the capacity to a hardware grid, call the ThreeFold Grid. </li>
<li>Dispersion over multiple sites ensures 100% privacy of the data, as no farmer knows what the data is about (zero knowledge storage system). Even a quantum computer cannot decrypt the data on a node, as one node contains insufficient information to unambiguously recreate the authentic data.</li>
<li>Data can’t be lost: there is a protection for datarot, data will auto-repair.</li>
<li>Data is append-only and immutable by design of the protocol, so it’s fit for storing ledger history. Even with sites going down, data is not lost with ‘operational’ backup nodes in place.</li>
<li>Up to 10x more efficient than storing on classic storage cloud systems. Overhead of about 20% is sufficient to have a secure archive.</li>
<li>Can be mounted as filesystem on any OS or any deployment system (OSX, Linux, Windows, Docker, Kubernetes, TFGrid, ...).</li>
<li>It is compatible with +/- all data workloads (exception: high performance data driven workloads like a database).</li>
<li>Self-healing: when node or disk lost, storage system can get back to original redundancy level.</li>
<li>Helps with compliance to privacy regulations like GDPR (as the hosting facility has no view on what is stored, information is encrypted and incomplete).</li>
<li>Hybrid : can be installed onsite, public, private, ...</li>
<li>Read-write caching on encoding node (the front end).</li>
</ul>
<h4 id="threefold-qsfs-sub-components-1"><a class="header" href="#threefold-qsfs-sub-components-1">ThreeFold QSFS sub-components</a></h4>
<p>QSFS being a prime candidate to consider for blockchain pruning purposes has a number of sub-components that can be put to use for achieving the pruning solution.  Here's a brief description of some of these:</p>
<h5 id="0-db-storage-engine-1"><a class="header" href="#0-db-storage-engine-1">0-db storage engine</a></h5>
<p>This is an always-append database, which stores objects in an immutable format, which allows to have history out-of-the-box, good performance on disk, low overhead, easy data structure, easy backup (linear copy and immutable files).
We use two types of 0-db: </p>
<ul>
<li>One for the storage backend </li>
<li>One for 0-db-fs, which is where data needs to be, to be available via the fuse filesystem. This 0-db can offload its data to an external process (user-defined) and can also request missing data to be retrieved, if some data are missing.</li>
</ul>
<p>This enables the database to spread and not always use local storage space if data is not read.</p>
<p>One external process to handle these cases is 0-stor-v2.</p>
<h5 id="0-db-fs-fuse-layer-which-uses-the-storage-engine-in-an-optimized-way-1"><a class="header" href="#0-db-fs-fuse-layer-which-uses-the-storage-engine-in-an-optimized-way-1">0-db-fs FUSE layer which uses the storage engine in an optimized way</a></h5>
<p>This is a simple filesystem driver which uses 0-db as the primary storage engine.
Directories and metadata are stored in a dedicated namespace, file payloads are saved in another dedicated namespace.
The filesystem uses an internal cache system made, not for performance, but to optimize how data is stored in the 0-db, to avoid overhead as much as possible.</p>
<h5 id="0-stor-v2-engine-to-savebackup-data-to-safe-location-1"><a class="header" href="#0-stor-v2-engine-to-savebackup-data-to-safe-location-1">0-stor-v2 engine to save/backup data to safe location</a></h5>
<p>This tool can be used as external process for 0-db, or can be used for any purpose. It just takes one file as input, it encrypts this file in AES based on a key user-defined, encodes the file and spreads the data to multiple 0-db’s. Based on the policy (configurable), some amount of 0-db’s can be unreachable, data can still retrieved and missing database can even be rebuilt to keep full consistency available.</p>
<p>Metadata needed to get data back from 0-db in the right order, are stored in others 0-db.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h1>
<p>Recommendation is to do the POC (milestone 2) in Q1/Q2 of 2022.  Threefold is able to free up the engineering resources based on the proceeds of milestones 1 part of the grant and the outlook to receive the proceed for milestone number 2.</p>
<blockquote>
<p>TODO: need to describe we already did 70% of the work, ...</p>
</blockquote>
<p>describe timing, planning, what to do by when, ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-1"><a class="header" href="#limitations-1">limitations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgement"><a class="header" href="#acknowledgement">acknowledgement</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>

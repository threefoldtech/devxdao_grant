<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>requirements</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro36/research_intro.html"><strong aria-hidden="true">1.</strong> GRANT description</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Milestone 1: CasperLabs 1-click blockchain node deployment</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/research_intro.html"><strong aria-hidden="true">2.1.</strong> Decentralised Cloud</a></li><li class="chapter-item expanded "><a href="../implementation/implementation.html"><strong aria-hidden="true">2.2.</strong> Implementation</a></li><li class="chapter-item expanded "><a href="../implementation/limitations.html"><strong aria-hidden="true">2.3.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">2.4.</strong> Conclusion</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Milstone 2: CasperLabs blockchain pruning solution design</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro37/research_intro.html"><strong aria-hidden="true">3.1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="../status_quo/status_quo_intro.html"><strong aria-hidden="true">3.2.</strong> Status Quo</a></li><li class="chapter-item expanded "><a href="../literature/literature.html"><strong aria-hidden="true">3.3.</strong> Literature</a></li><li class="chapter-item expanded "><a href="../decentralized_cloud/decentralized_cloud.html"><strong aria-hidden="true">3.4.</strong> Decentralized Cloud</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../solution/tf_quantum_safe_storage.html"><strong aria-hidden="true">3.4.1.</strong> tf_quantum_safe_storage</a></li><li class="chapter-item expanded "><a href="../requirements/requirements.html" class="active"><strong aria-hidden="true">3.4.2.</strong> requirements</a></li></ol></li><li class="chapter-item expanded "><a href="../research/research.html"><strong aria-hidden="true">3.5.</strong> Research</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../research/deployment/casper_deployment.html"><strong aria-hidden="true">3.5.1.</strong> casper_deployment</a></li><li class="chapter-item expanded "><a href="../research/qsfs_performance.html"><strong aria-hidden="true">3.5.2.</strong> qsfs_performance</a></li><li class="chapter-item expanded "><a href="../research/storage_integration.html"><strong aria-hidden="true">3.5.3.</strong> storage_integration</a></li></ol></li><li class="chapter-item expanded "><a href="../solution/solution.html"><strong aria-hidden="true">3.6.</strong> Solution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../solution/tf_quantum_safe_storage.html"><strong aria-hidden="true">3.6.1.</strong> tf_quantum_safe_storage</a></li></ol></li><li class="chapter-item expanded "><a href="../implementation/implementation.html"><strong aria-hidden="true">3.7.</strong> Implementation</a></li><li class="chapter-item expanded "><a href="../implementation/limitations.html"><strong aria-hidden="true">3.8.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="../conclusion.html"><strong aria-hidden="true">3.9.</strong> Conclusion</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Milestone 3: CasperLabs blockchain pruning solution implementation</div></li><li class="chapter-item expanded "><a href="../acknowledgement.html"><strong aria-hidden="true">5.</strong> acknowledgement</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="requirements"><a class="header" href="#requirements">Requirements</a></h1>
<blockquote>
<p>TODO: needs to be broken appart in multiple files, use some tables, ...</p>
</blockquote>
<blockquote>
<p>TODO: think more what do we want to achieve adn putrequirements as such</p>
</blockquote>
<p>A blockchain is in essence a ledger of immutable records that are always append and therefore linked and a chain, The total chain forms the &quot;end state&quot;. In order to proof validity of this end state, the complete history needs to be kept from the genesis time of the blockchain to now. </p>
<p>Blockchains enable organizations to run decentralized, they allow value transaction to be done without a third party in the middle and any other use case of blockchain technology always revolves around decentralization.  The permissionless blockchain provide the most pure form of decentralization where node owners and operators decide for themselves whether the reward for operating a node is sufficient for them to get involved (or not).  Permissioned blockchains have a slightly less decentralized character but certainly have a distributed character where the reward is not just governed by an algorithm because here there might be a legal entity involved to orchestrate the rewards system.  This  legal entity might be a DAO (Distributed Autonomous Organization).</p>
<p>The number and types of implementations of blockchains (supporting the growth in adoptions for traditional use cases and  DAO's) is going to grow exponentially, there is a need for level-1 blockchain protocols to be able to deal with the increased volume of transactions and history, making pruning a necessity.</p>
<p>Increase in data volume and transactions volume will create issues at some point in time, a ledger holding the complete chain data will become too big for a key aspects of a blockchain:</p>
<ul>
<li>fast transaction times require minimum synchronization time.</li>
<li>security and proof of validity requires the complete chain to be stored many times over to overcome a 51% attack</li>
<li>decentralized operations is key but operating a full nodes becomes more expensive by excessive chain data growth which in the long run will rule out people that do not have the means to afford such hardware.</li>
</ul>
<p>All of the above threatens the decentralization of any layer-1 blockchain project in general.</p>
<p>From the literature researched we formed ideas how we can come to a &quot;non intrusive&quot; pruning system for regular blockchain protocols without necessarily make major changes to the existing blockchain and consensus algorithms. To form such a solution there are a number of technology components that will make creating such a solution possible or easier to create.  To architect methods to solve this problem we have opted to use the ThreeFold data processing and storage stack which presents a unique decentralized utility / cloud platform with some unique storage capabilities that will make developing this solution possible.</p>
<h2 id="solution-architecture"><a class="header" href="#solution-architecture">Solution architecture</a></h2>
<p>To honor decentralization aspect the of any chain data the pruning solution cannot be governed or owned by one (or a few) legal entities, it has to follow the same principle of being permissionless or somehow permissioned with a DAO governing the permissioned aspects. </p>
<p>To make this work we have to create a set of requirements to what the solution needs to be designed to.</p>
<h3 id="high-level-requirements"><a class="header" href="#high-level-requirements">High level requirements</a></h3>
<p>In order to start looking at solutions let's first draft some requirement that we believe are instrumental to the solution.  The requirements are:</p>
<ol>
<li>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software.</li>
<li>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes <em>or</em> it should use a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO.</li>
<li>2the pruning solution should store the chain data such that it provides a proof of recovery method </li>
<li>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</li>
<li>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</li>
</ol>
<!-- ### Protocol

The protocol solving the storage and pruning challenge consists of the following : 
- The current state is kept locally and recalculated when new transactions come in, before spreading it out;
- Historical transactions are directly stored in QSFS, available for consultation and synchronisation purposes (in case new validators join). 
- The history is organised as one file system, which constitutes the data using chunks from different redundant shards, hosted on storage infrastructure of multiple independent hardware providers. Each of the shards contains insufficient information to recollect the original data, but using all shards combined allows to recollect the pieces with minimal overhead. 

#### Challenges and solutions to it

- Make sure that the data is sufficiently decentralized, i.e. spread over shards that are hosted on infrastructure of different providers. 
- Make sure that these 'shard hosters' keep the storage available, or that a sufficient amount of shards are recreated at a moment that shards become unavailable. The storage nodes need to remain alive. The consensus mechanism determines the need for incentivisation mechanisms. 
  - In a permissioned blockchain, using a Proof of Authority consensus driven blockchain, there is no real issue: here the participants have interest to have all history available, and no incentive is needed for them to make this happen. The QSS, in this case, is a way for participants to substantially reduce the need for space, remaining equally responsible for the history of transactions. 
  - In a permissionless blockchain, we need to find a mechanism to incentivize participants to keep also transaction history available, and even 'punish' node owners tricking the system, ex. retrieving the info by proxy-ing the service. A few ideas to cope with this issue : 
    - apply a higher-level protocol to interrogate the provider 
    - build into the protocol itself, and put the metadata on-chain

A node could be requested to provide a specific shard and hash it with a timestamp or specific nonce included, maybe running their own personalised 0-stor protocol instance.
The proof can be a merkle tree + root hash + a requested block, with the hash made based taking up a nonce/timestamp.-->
<h3 id="necessary-conditions"><a class="header" href="#necessary-conditions">Necessary conditions.</a></h3>
<p>Taking the high level requirements into consideration we take the following necessary conditions on board to design the solution:</p>
<p><strong>Necessary Condition 1 (NC1)</strong>. <em>Secure, autonomous, decentralized and distributed data processing and storage utility</em></p>
<p>To create autonomous, decentralized and distributed data processing and storage utility we need an operating system that provides maximum security by not allowing people to give it instructions or configure it.  To reach a distributed and decentralized grid of processing and storage capacity we cannot rely on people to install and operate standard operating systems.  A standard operating system would allow individual owners of these nodes to be able to see (and potentially manipulate) the incoming data parts to be stored.</p>
<p>ThreeFold has developed such an operating system that gets its instructions from a decentralized ledger where a smart contract governs the execution of such operational instructions.  Such an operating system would allow the compute and storage nodes involved in the pruning solution to be safe, private, sovereign and autonomous  in it's operations.</p>
<p><strong>Necessary condition 2 (NC2)</strong>. <em>Immutable and always-append storage device</em></p>
<p>Use a low level storage device that uses physical storage similar to how a blockchain create chain data: always append and immutable.  When data is committed to this storage device it cannot be deleted.  The data is committed and stored on this storage device for as long as this device is part of the storage system for pruned data.</p>
<p><strong>Necessary condition 3 (NC3)</strong>. <em>Encrypted secure networking</em></p>
<!--  (maybe to be deleted, as there's not really data to secure when pruning) -->
<p>Use secure and encrypted networking between the blockchain nodes and the <em>remote</em> storage utility.  Chain data needs to be transported off node and we need to have certainty that data cannot be changed or messed with in the transport part of the pruning process. Therefore encrypted networking using an overlay network technology is an important component for taking chain data off blockchain nodes.</p>
<p><strong>Necessary condition 4 (NC4)</strong>. <em>A filesystem that presents remote storage to blockchain node</em></p>
<p>For minimal to no impact to general blockchain nodes, the off-node storage utility should be presenting itself on the blockchain node as a normal filesystem.  All activities of storing data away from the blockchain node and creating the necessary proof points along the way should require minimal to no impact on the blockchain software.  Proof point should include:</p>
<ul>
<li>authenticity of being pruned from a particular node</li>
<li>comparing off chain data from different nodes to contain the same data</li>
<li>de-duplicating data</li>
<li>other activities to condense the data footprint and make the whole blockchain more efficient and scalable</li>
</ul>
<p>Some blockchain protocols have built in capabilities that allow partial backup of chain data and provide the required proof of the authenticity of the partial backup which makes the remote storage filesystem an ideal way to take data off-node.</p>
<p><strong>Necessary condition 5 (NC5)</strong> . <em>Secure access to remote stored and de-duplicated data</em></p>
<p>Provide secure access to the stored history of the chains and make all nodes (ideally) use de-duplicated copies of the historic data.</p>
<p><strong>Necessary condition 6 (NC6)</strong>. <em>Proof of recoverability</em></p>
<p>When data is stored off node in a de-duplicated format there should be a regular check if the pruned data is recoverable.  This necessary condition will also create the opportunity for new nodes to join at and start validating and securing from the current chain state while in the background cycling back the the genesis block on the pruned chain data and create proof of recoverability for the while chain. </p>
<h2 id="solution-components"><a class="header" href="#solution-components">Solution components</a></h2>
<p>To fullfil the necessary conditions mentioned earlier there are a number of components in the ThreeFold technology stack that meet these condition and will be considered to be part of the pruning solution.  Here is a brief description of how components meet the conditions.</p>
<h3 id="nc1-secure-and-autonomous-operating-system"><a class="header" href="#nc1-secure-and-autonomous-operating-system">NC1: Secure and autonomous Operating System</a></h3>
<p>The principles to build a secure and autonomous operating system to build a decentralized and distributed grid of capacity are as follows:</p>
<ul>
<li><em>Autonomy</em>: to create compute, storage and networking capacity everywhere you can not rely on a remote (or a local) maintainer of the operating system. Also owners should not have to be operating system administrators.  By making the OS autonomous and not allowing owners or systems administrators to log in to the OS you make it a very secure operating system.</li>
<li><em>Simplicity</em>: An operating system should be simple, able to exist anywhere, for anyone, good for the planet.  Simplicity also enhances the overall security of a system </li>
<li><em>Stateless</em>: In a grid (Peer To Peer) set up, the sum of the components is providing a stable basis for single elements to fail and not bring the whole system down. Therefore, it is necessary for single elements to be stateless, and the state needs to be stored within the grid.</li>
</ul>
<img src="./img/threefold__zero_os_overview.jpg" alt="threefold_zero_os_overview" width="800"/>
<p>Building an autonomous, simple and stateless OS is not an easy feat.  Not having access means that is has to be 100% right at time of deployment.  Zero-OS has been developed and improved over the last 5 years and is now ready to be the capacity generator for secure IT workloads where compute, storage and networking components interact.</p>
<h3 id="nc2-immutable-and-always-append-storage-protocol"><a class="header" href="#nc2-immutable-and-always-append-storage-protocol">NC2: Immutable and always-append storage protocol</a></h3>
<p>In such an autonomous operating system storing data can be done in a very secure manner.  As owners, administrators and users do not have direct access to the operating system a very secure environment is created to run applications and store data.  Also since this operating system is made to form a grid creating ubiquitous compute, storage and network utility local storage devices can be used to make a &quot;dispersed&quot; storage system.</p>
<p>At the foundation of such a dispersed storage system sits a zero-DB.
Zero-db is a fast and efficient key-value store (redis-protocol compatible), which makes data persistent inside an always append data file, with namespaces support.  This zero-DB is able to receive and send information over a secure network that spans between all the zero-OS's and as such many zero-DB's can together create a large storage lake.</p>
<p>The Zero-DB stores data like a key-value store, and can operate (when configured to do so) to store data sequentially which makes it an &quot;always append&quot; storage device.  For caching purposes it can also be configured to not do this.</p>
<img src="./img/threefold__zdb_arch.jpg" alt="threefold_zdb_arch" width="800"/>
<h3 id="nc3-encrypted-secure-networking-the-planetary-network"><a class="header" href="#nc3-encrypted-secure-networking-the-planetary-network">NC3: Encrypted secure networking: the Planetary Network</a></h3>
<p>The planetary network is an overlay network which lives on top of the existing internet (or any other network created). In this network, everyone can direct connect to everyone and routing does not rely on ISP and Tier 1 providers routing tables. The technology uses a Distributed Hash Table that allows all participating nodes to find the best network path to where it needs to send data. End-to-end encryption between application on the zero-OS's.</p>
<p>Each user and network point is strongly authenticated and uniquely identified, independent of the network carrier used. There is no need for a centralized firewall or VPN solutions, as there is a circle based networking security in place.</p>
<p>Benefits :</p>
<ul>
<li>shortest possible paths between peers, independent of the network providers routing decisions</li>
<li>end-to-end encrypted data transport create full security</li>
<li>peer2peer links like meshed wireless</li>
<li>broken internet links do not affect the operating of traffic by re-routing traffic when needed</li>
</ul>
<img src="./img/threefold__planet_net_.jpg" alt="planetary_network" width="800"/>
<h3 id="nc4-filesystem-that-presents-remote-storage-to-blockchain-node"><a class="header" href="#nc4-filesystem-that-presents-remote-storage-to-blockchain-node">NC4: Filesystem that presents remote storage to blockchain node</a></h3>
<p>Quantum Safe Storage System uses a dispersed storage algorithm to distribute the data in a smart way and store data in different locations. The original object is fragmented, compressed and encrypted, and than a &quot;description&quot; is created of that compressed and encrypted fragment which is stored. The original compressed and encrypted data is deleted.  Only that description of that data part  of the information is stored, making it impossible to understand what data(part) is stored on a single device as you need all the descriptions together to be able to &quot;un-describe&quot; the compressed and encrypted original data</p>
<p>The data is described in a way such that a person aiming to hack into the low-level data (which is almost impossible in itself), will only find non-relevant information on this storage infrastructure and the other data shards can’t be re-created, making it quantum-proof.</p>
<p>Quantum Safe Storage System offers the following storage benefits:</p>
<ul>
<li>Store Petabytes of data at hyper-competitive pricing.</li>
<li>Quantum-safe security (not even a quantum computer can hack).</li>
<li>A filesystem interface see Quantum Safe Filesystem</li>
<li>Unlimited scalability provided by the ThreeFold P2P infrastructure.</li>
<li>Self-healing capability of the storage layer ensures your data remains available at all times.</li>
</ul>
<img src="./img/threefold__zos_zstor.jpg" alt="zos_zero_store" width="800"/>
<h3 id="nc5-secure-access-to-de-duplicated-data"><a class="header" href="#nc5-secure-access-to-de-duplicated-data">NC5: Secure access to de-duplicated data</a></h3>
<p>...</p>
<p>ThreeFold Tech has developed the technology to store immutable records in a more space efficient way, relying on a fully decentralized grid of storage capacity. No participant has the full storage volume on his hard drive, however the combination of all participants allows recomposing of the full ledger with all records. This method brings many benefits: </p>
<ul>
<li>The storage happens in a very, quantum-resilient way, as attacking one chunk gives insufficient information to recreate the authentic data;</li>
<li>Storage grows slower over time compared to a classic blockchain setup, as storage overhead can be limited to about 20% instead of the ‘traditional’ 10000% (in the case of 100 participants running a blockchain node) overhead;</li>
<li>It allows for an easy way to implement pruning: only the current state is really required to be stored locally, and when transactions come in, a recalculation is made, and the storing of the historical transactions is directly done using QSFS</li>
</ul>
<h3 id="nc6-proof-of-retrievability-por"><a class="header" href="#nc6-proof-of-retrievability-por">NC6: Proof of Retrievability (POR)</a></h3>
<p>We need to have a way for archived chain to have proof of retrievability (POR). A POR is a protocol in which a server/archive proves to a client that a target file F is intact, in the sense that the client can retrieve all of F from the server with high probability.</p>
<p>For a good working pruning solution POR is a necessary conditions</p>
<h2 id="proposed-solution-methods-to-architect-a-pruning-solution"><a class="header" href="#proposed-solution-methods-to-architect-a-pruning-solution">Proposed solution methods to architect a pruning solution</a></h2>
<h3 id="introduction"><a class="header" href="#introduction">Introduction</a></h3>
<p>For many blockchain nodes every (full / validator) node that partakes in the blockchain operation run the layer-1 blockchain software which is part of the blockchain operations.  At this point in time we leave the complexities out that come with the the blockchain being permissionless or permissioned.  This has major impact on how nodes build trust between themselves and the resulting consensus mechanism that operates the blockchain protocol.  For this part of the research we are going to focus on how these blockchain nodes store that data after consensus and trust has been build between all participating nodes.</p>
<h3 id="method-1-use-traditional-full-and-incremental-backup-principles-to-backup-a-database-offchain"><a class="header" href="#method-1-use-traditional-full-and-incremental-backup-principles-to-backup-a-database-offchain">Method 1: Use traditional full and incremental backup principles to backup a database offchain</a></h3>
<h4 id="description"><a class="header" href="#description">Description</a></h4>
<p>Any blockchain node uses local available disk drives to write its full chain data and chain state to.  For some (layer-1) protocols a database is used (like <a href="https://github.com/LMDB/bitmonero">Monero</a>) and for others other data formats have been chosen. These formats might be databases, key values stores or other means of putting data in a structured format before committing it to disk.</p>
<p>Popular cryptocurrencies use a mix of LevelDB and BerkeleyDB. High-performance blockchain databases such as BigchainDB and ProvenDB are using MongoDB.  So each blockchain node runs a local database of sort to store its local chain data and indexes it in a certain way to make it searchable and fast responding to queries.</p>
<img src="../img/blockchain_local_operation.svg" alt="blockchain_pruning_option_1" width="800"/>
<p>In such a setup one can look at database specific export or backup features to partial exports and backups to store a part af the chain data off-node.</p>
<img src="../img/blockchain_local_operation_pruning.svg" alt="blockchain_pruning_option_1" width="800"/>
<p>In this method the blockchain node database is used to create a periodic export of the database and all of it's new stored blocks and it is store on a local fuse based file system than has a local storage devices for physical storage.  The fuse filesystem has hooks built in to engage an erasure coding engine that takes the new data, create data fragments from it, compresses and encrypts tha fragments and then creates a mathematical description of these fragments (plus creates mode mathematical descriptions based on the same compressed and encrypted fragments to create redundancy).  For a more detailed description how this works please see <a href="https://library.threefold.me/info/threefold#/qss/threefold__qss_algorithm">here</a>.</p>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Requirement</th><th style="text-align: center">Achieved?</th><th style="text-align: center">Remarks</th></tr></thead><tbody>
<tr><td style="text-align: left">pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td style="text-align: center">yes</td><td style="text-align: center">1.</td></tr>
<tr><td style="text-align: left">the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td style="text-align: center">yes</td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: left">the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td style="text-align: center">No</td><td style="text-align: center">2.</td></tr>
<tr><td style="text-align: left">the pruning solution should store the chain data such that it provides a proof of recovery method</td><td style="text-align: center">TBD</td><td style="text-align: center">3.</td></tr>
<tr><td style="text-align: left">the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: left">the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
</tbody></table>
</div>
<p><em>Remarks</em></p>
<ol>
<li>this methods uses all of the participating node to run software and store data. The fragment dispatcher and dedupe process creates consensus on which fragment is stored on what node and creates meta data to be able to retrieve the de-duplicated DB export container chain data.</li>
<li>the external storage facility to the node are all the other blockchain nodes <code>N-1</code>.  Since the blockchain protocol builds trust and consensus the trust is implicit here.</li>
<li>the proof of recovery method is working for a file based storage system build with this technology where there is a single data injection point.  In this use case there are <code>N</code> data injection points which is theoretically inject the same data. The proof algorithm needs to be build but research shows that this can be done.</li>
</ol>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th style="text-align: center">Achieved?</th><th style="text-align: center">Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td style="text-align: center">Yes</td><td style="text-align: center">1.</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td style="text-align: center">Yes</td><td style="text-align: center">2.</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td style="text-align: center">Yes</td><td style="text-align: center">3.</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td style="text-align: center">Yes</td><td style="text-align: center">4.</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td style="text-align: center">Yes</td><td style="text-align: center">5.</td></tr>
</tbody></table>
</div>
<p><em>Remarks</em></p>
<ol>
<li>The ThreeFold stack is version 3 and has a proven track record of providing decentralised and distributed data processing and storage utility.</li>
<li>This is what zero-DB has been designed to do. Please find more information <a href="https://github.com/threefoldtech/0-db">here</a></li>
<li>The ThreeFold planetary network does exactly this. PLease find more information <a href="https://github.com/threefoldtech/TF-NetworkConnector_">here</a></li>
<li>Please find mode information <a href="https://github.com/threefoldtech/quantum-storage">here</a></li>
<li>the proof of recovery method is working for a file based storage system build with this technology where there is a single data injection point.  In this use case there are <code>N</code> data injection points which is theoretically inject the same data. The proof algorithm needs to be build but research shows that this can be done.</li>
</ol>
<h3 id="method-2-install-and-use-additional-software-on-the-node-to-prune-chain-data"><a class="header" href="#method-2-install-and-use-additional-software-on-the-node-to-prune-chain-data">Method 2: Install and use additional software on the node to prune chain data</a></h3>
<p>Method 2 is about integrating the backup tooling into the node software. Fuse file system will be created on a node, and data will be sent to ZSTOR. Then, a proof process is executed to build consensus on the same data that is archived in zstor as the one that was used in the block validation consensus. A block is split up in fragments, parity blocks are added for both the data and for the proofs. Once fragments are created, they are distributed over different nodes: each of p+q nodes stores one of the created fragments, into the zdb present in the node. </p>
<img src="../img/pruning_block_write_option_1.svg" alt="blockchain pruning option 1" width="800"/>
<p>&lt;<Scott to complete>&gt;</p>
<p><strong>Necessary conditions</strong> </p>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td>No</td><td>No</td></tr>
<tr><td>the pruning solution should store the chain data such that it provides a proof of recovery method</td><td>TBD</td><td>No</td></tr>
<tr><td>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td>Yes</td><td>No</td></tr>
<tr><td>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td>Yes</td><td>No</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td>Yes</td><td>No</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td>Yes</td><td>No</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td>Yes</td><td>No</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td>Yes</td><td>No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="method-3-integrate-pruning-software-module-into-permissionless-blockchain"><a class="header" href="#method-3-integrate-pruning-software-module-into-permissionless-blockchain">Method 3: Integrate pruning software module into permissionless blockchain</a></h3>
<p>Method 2 could work well in a permissioned setup. 
Method 3 is an add-on to method 2 to make it also work in a permissionless consensus model. </p>
<p>The problem with permissionless setups is the fact that there is no hard commitment from the validators that they will continue operating, and that a validator expects some incentive in return for the validator services provided. Especially when dealing with historic information, current consensus models only provide in rewards for closing the current blocks, with the 'obligation' to also keep history up. This leads to the high redundancy in storage. Pruning in these setups is only solved creating a hierarchies in the node structure, which is contradictory to the decentralized nature of permissionless blockchains. </p>
<p>We propose a four-step approach for a non-hierarchical pruning protocol that works in a permissionless setup. It involves elections for the storage of historic batches, each time a new batch of blocks is being built. </p>
<h4 id="step-1--consensus"><a class="header" href="#step-1--consensus">Step 1 : Consensus</a></h4>
<p>The first step in the consensus protocol does not change: n nodes agree on validity of blocks. Once consensus is achieved (using whatever consensus protocol like PoS, PoW, ...) records are stored and de-duplicated over all n nodes. 
With one difference, however, which is that the transactions are stored in a Z-Stor dedupe format, over p storage nodes + q redundant ones (typically 20% of overhead) in a Zero-DB format. </p>
<h4 id="step-2--fill-block-batch"><a class="header" href="#step-2--fill-block-batch">Step 2 : Fill block batch</a></h4>
<p>We propose to group a number of blocks, either for an agreed number of blocks. Idea is to come to a sufficient volume to put aside (ex. 30 MB), and keep the transactional history on-chain as long as the agreed block number hasn't been reached. During this period, history is collected in n*(p+q) equal chunks of data.</p>
<h4 id="step-3--batch-closing"><a class="header" href="#step-3--batch-closing">Step 3 : Batch closing</a></h4>
<p>Once the agreed block number has been fully completed (= consensus achieved), the chunks are closed and are ready to be put off-chain. The zstor format ensures that data is immutable, a fingerprint is created and linking information to where the chunks can be found. This information is registered on-chain. </p>
<h4 id="step-4--off-chain-storage-follow-up"><a class="header" href="#step-4--off-chain-storage-follow-up">Step 4 : Off-chain storage follow-up</a></h4>
<p>A few challenges arise with this setup :</p>
<ul>
<li>Data rot can happen, a node can disconnect or other events can happen making that a node starts behaving as a bad actor. </li>
<li>Every time a batch is closed, the metadata describing the location of the historic batches also go off-chain. </li>
</ul>
<p>Both elements require an active follow-up of where historic batches of transactions are to be found is needed. 
This is why the following is proposed:</p>
<ul>
<li>Within each new storage batch process, a process is launched to register the location of historic batches on the new active part of the chain. </li>
<li>Over time, a number of batches are created. Let's call the number of completed batches <code>y</code>. </li>
<li>An election needs to happen of <code>y * (p + q)</code> chunks. During this election, nodes propose the storing of a chunk, with a number of rules: 
<ul>
<li>The number of eligible chunks per batch per node is less than q (and preferably 1), in order to guarantee that the information is decentralized enough to ensure continuity of service in case a node gets disconnected. </li>
<li>A batch can't be closed as long as the election process for each of the <code>y * (p + q)</code> hasn't been completed. </li>
<li>An election process is triggered by 'candidates', launching a 'proof of storage' transaction, indicating the location of the chunk and a fingerprint of the data including recent info (nonce, timestamp, ... ) and proof of authenticity. The election process for a history batch is completed once <code>p + q</code> transactions are selected. </li>
</ul>
</li>
<li>For older chunks, re-election in every new active batch is possible. However, a chunk storage holder should present his 'proof of storage' in every new batch. </li>
<li>In a permissioned model, the election of new chunk holders is part of the authority rights, and no incentive is to be foreseen. For permissionless models, an incentivization mechanism needs to be worked out for every new election. </li>
</ul>
<h4 id="how-to-split-up-the-data-chunks-when-a-batch-has-just-been-completed-"><a class="header" href="#how-to-split-up-the-data-chunks-when-a-batch-has-just-been-completed-">How to split up the data chunks when a batch has just been completed ?</a></h4>
<p>At batch completion, there are logically n*(p+q) chunks available. However, this completed batch can't be pruned until the completion of the next batch, during which election happens of p+q 'historic chunk batch holders'. 
Number of chunks for every election needed is p+q, with p and q natural numbers and p&gt;1, q&gt;0. q=0 is not viable, as data rot might occur, so the idea is that there is always an objective to keep p+q chunks available, and when a chunks gets unreachable, a new chunk is being created.</p>
<p>The intention is to have (p+q) chunks available at any moment in time, for each batch, hence the re-election of every chunk for every new batch. The keeping of 1 or more of these chunks can be incorporated into the validator node code, but will require way less storage volume than the current full nodes. Moreover the storage can be kept off-chain, as an 'active' transaction archive. </p>
<h4 id="how-to-recollect-the-pieces-if-a-historical-transaction-is-to-be-recovered-"><a class="header" href="#how-to-recollect-the-pieces-if-a-historical-transaction-is-to-be-recovered-">How to recollect the pieces if a historical transaction is to be recovered ?</a></h4>
<ul>
<li>In every of the y completed storage batches, all info is available as a transaction to recover y * (p + q) chunks, and with this info the full transaction history can be recovered, using y * p chunks and y * q spare ones. </li>
</ul>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td>No</td><td>No</td></tr>
<tr><td>the pruning solution should store the chain data such that it provides a proof of recovery method</td><td>TBD</td><td>No</td></tr>
<tr><td>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td>Yes</td><td>No</td></tr>
<tr><td>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td>Yes</td><td>No</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td>Yes</td><td>No</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td>Yes</td><td>No</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td>Yes</td><td>No</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td>Yes</td><td>No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="method-4-use-an-external-decentralized-storage-facility-and-uses-chain-consensus"><a class="header" href="#method-4-use-an-external-decentralized-storage-facility-and-uses-chain-consensus">Method 4: Use an external (decentralized storage facility and uses chain consensus)</a></h3>
<p>The most elegant solution would be to have the blockchain node
<img src="../img/pruning_block_write_option_2.svg" alt="blockchain pruning option 2" width="800"/></p>
<p><strong>Requirements</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>pruning solution should be able to run <em>on</em> node as well as <em>off</em> node by using largely the same method and software</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution should be able to work using the blockchain nodes local storage capacity only and store de-duplicated chain data on these nodes resulting in an over all lower amount of total disk space usage used for all <code>N</code> nodes.</td><td>yes</td><td>No</td></tr>
<tr><td>the pruning solution uses a trusted storage facility that uses external storage capacity to store de-duplicated chain data and is (possibly) governed by a DAO</td><td>No</td><td>No</td></tr>
<tr><td>the pruning solution should store the chain data such that it provides a proof of recovery method</td><td>TBD</td><td>No</td></tr>
<tr><td>the pruning solution should transport data (by network) <em>off</em> node in such a way that it cannot be stopped by entities (read ISP's, governments and other legal entities)</td><td>Yes</td><td>No</td></tr>
<tr><td>the pruning solution should allow node operators to <em>opt in</em> and <em>opt out</em> of using it.</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<p><strong>Necessary conditions</strong> </p>
<div class="table-wrapper"><table><thead><tr><th>Nr.</th><th>Necessary condition</th><th>Achieved?</th><th>Remarks</th></tr></thead><tbody>
<tr><td>1</td><td>Secure, autonomous, decentralized and distributed data processing and storage utility</td><td>Yes</td><td>No</td></tr>
<tr><td>2</td><td>Immutable and always-append storage device</td><td>Yes</td><td>No</td></tr>
<tr><td>3</td><td>Encrypted secure networking</td><td>Yes</td><td>No</td></tr>
<tr><td>4</td><td>A filesystem that presents remote storage to blockchain node</td><td>Yes</td><td>No</td></tr>
<tr><td>5</td><td>Secure access to remote stored and de-duplicated data</td><td>Yes</td><td>No</td></tr>
<tr><td>6</td><td>Proof of recoverability</td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../solution/tf_quantum_safe_storage.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../research/research.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../solution/tf_quantum_safe_storage.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../research/research.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
